#!/usr/bin/env python3
"""
æ•°æ®å®‰å…¨æå–å·¥å…· - GUIç‰ˆ (å¸¦å¯¼å‡ºåŠŸèƒ½å’Œè¿›åº¦æ˜¾ç¤º)
"""

import os
import re
import json
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from pathlib import Path
import threading
from datetime import datetime
import sys

class DataExtractorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("æ•°æ®å®‰å…¨æå–å·¥å…· Generated by R1yhtp")
        self.root.geometry("700x700")  # å¢åŠ é«˜åº¦ä»¥å®¹çº³æ›´å¤šæ§ä»¶
        self.root.configure(bg='#2c3e50')
        
        # è®¾ç½®çª—å£å›¾æ ‡
        self.set_icon()
        
        # åŠ è½½é…ç½®
        self.config = self.load_config()
        self.patterns = self.config["patterns"]
        
        # å­˜å‚¨æ‰«æç»“æœ
        self.scan_results = {}
        
        # åˆ›å»ºç•Œé¢
        self.create_widgets()
        
        # çŠ¶æ€å˜é‡
        self.is_scanning = False
    
    def get_resource_path(self, filename):
        """è·å–èµ„æºæ–‡ä»¶çš„æ­£ç¡®è·¯å¾„"""
        try:
            base_path = sys._MEIPASS
        except Exception:
            base_path = os.path.abspath(".")
        return os.path.join(base_path, filename)
    
    def set_icon(self):
        """è®¾ç½®çª—å£å›¾æ ‡"""
        icon_paths = [
            "app.ico",
            os.path.join(os.path.dirname(__file__), "app.ico"),
            self.get_resource_path("app.ico")
        ]
        
        for icon_path in icon_paths:
            try:
                if os.path.exists(icon_path):
                    self.root.iconbitmap(icon_path)
                    return
            except:
                continue
    
    def load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        default_config = {
            "patterns": {
                "phone": {
                    "pattern": r'(?<!\d)1[3-9]\d{9}(?!\d)',
                    "description": "æ‰‹æœºå·",
                    "icon": "ğŸ“±"
                },
                "id_card": {
                    "pattern": r'(?<!\d)\d{17}[\dXx](?!\d)',
                    "description": "èº«ä»½è¯å·", 
                    "icon": "ğŸ†”"
                },
                "email": {
                    "pattern": r'(?<!\w)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?!\w)',
                    "description": "é‚®ç®±åœ°å€",
                    "icon": "ğŸ“§"
                },
                "ipv4": {
                    "pattern": r'(?<!\d)(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?!\d)',
                    "description": "IPv4åœ°å€",
                    "icon": "ğŸŒ"
                },
                "username": {
                    "pattern": r'(?<!\w)[a-zA-Z0-9_]{4,20}(?!\w)',
                    "description": "ç”¨æˆ·å",
                    "icon": "ğŸ‘¤"
                },
                "url": {
                    "pattern": r'https?://[^\s<>"{}|\\^`\[\]]+',
                    "description": "URLé“¾æ¥",
                    "icon": "ğŸ”—"
                },
                "mac_address": {
                    "pattern": r'(?<!\w)(?:[A-Fa-f0-9]{2}[:-]){5}[A-Fa-f0-9]{2}(?!\w)',
                    "description": "MACåœ°å€",
                    "icon": "ğŸ”Œ"
                },
                "date_ymd": {
                    "pattern": r'(?<!\d)(?:19|20)\d{2}[-/å¹´](?:0[1-9]|1[0-2])[-/æœˆ](?:0[1-9]|[12][0-9]|3[01])æ—¥?(?!\d)',
                    "description": "æ—¥æœŸ",
                    "icon": "ğŸ“…"
                },
                "md5": {
                    "pattern": r'(?<!\w)[a-fA-F0-9]{32}(?!\w)',
                    "description": "MD5å“ˆå¸Œ",
                    "icon": "ğŸ”’"
                },
                "base64": {
                    "pattern": r'(?<!\w)[A-Za-z0-9+/]{4,}={1,2}(?!\w)',
                    "description": "Base64ç¼–ç ",
                    "icon": "ğŸ“„"
                }
            }
        }
        
        config_paths = [
            "config.json",
            os.path.join(os.path.dirname(__file__), "config.json"),
            self.get_resource_path("config.json")
        ]
        
        for config_path in config_paths:
            try:
                if os.path.exists(config_path):
                    with open(config_path, 'r', encoding='utf-8') as f:
                        user_config = json.load(f)
                        default_config.update(user_config)
                    break
            except:
                continue
        
        return default_config
    
    def create_widgets(self):
        """åˆ›å»ºç•Œé¢ç»„ä»¶"""
        # åˆ›å»ºä¸»å®¹å™¨
        self.main_container = tk.Frame(self.root, bg='#ecf0f1', bd=2, relief=tk.RAISED)
        self.main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # æ ‡é¢˜åŒºåŸŸ
        title_frame = tk.Frame(self.main_container, bg='#3498db', height=80)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(title_frame, 
                              text="ğŸ” æ•°æ®å®‰å…¨æå–å·¥å…·", 
                              font=("å¾®è½¯é›…é»‘", 18, "bold"),
                              fg='white', 
                              bg='#3498db')
        title_label.pack(expand=True)
        
        subtitle_label = tk.Label(title_frame,
                                 text="ä¸“ä¸ºCTFå’Œæ•°æ®å®‰å…¨è®¾è®¡çš„æ™ºèƒ½æå–å·¥å…·",
                                 font=("å¾®è½¯é›…é»‘", 10),
                                 fg='#eaf2f8',
                                 bg='#3498db')
        subtitle_label.pack(expand=True)
        
        # ä¸»è¦å†…å®¹åŒºåŸŸ
        content_frame = tk.Frame(self.main_container, bg='#ecf0f1')
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # æ­¥éª¤1: é€‰æ‹©ç›®æ ‡
        step1_frame = self.create_step_frame(content_frame, "æ­¥éª¤1: é€‰æ‹©æ‰«æç›®æ ‡", 0)
        
        tk.Label(step1_frame, text="ç›®æ ‡è·¯å¾„:", bg='#ecf0f1', font=("å¾®è½¯é›…é»‘", 9)).grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        
        self.target_var = tk.StringVar()
        self.target_entry = tk.Entry(step1_frame, textvariable=self.target_var, width=50, font=("å¾®è½¯é›…é»‘", 9))
        self.target_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 10))
        
        tk.Button(step1_frame, text="ğŸ“ æµè§ˆæ–‡ä»¶", 
                 command=self.browse_file, 
                 bg='#3498db', fg='white', font=("å¾®è½¯é›…é»‘", 9)).grid(row=0, column=2, padx=(0, 5))
        
        tk.Button(step1_frame, text="ğŸ“‚ æµè§ˆç›®å½•", 
                 command=self.browse_directory, 
                 bg='#3498db', fg='white', font=("å¾®è½¯é›…é»‘", 9)).grid(row=0, column=3)
        
        self.recursive_var = tk.BooleanVar(value=True)
        tk.Checkbutton(step1_frame, text="é€’å½’æ‰«æå­ç›®å½•", 
                      variable=self.recursive_var, 
                      bg='#ecf0f1', 
                      font=("å¾®è½¯é›…é»‘", 9),
                      activebackground='#ecf0f1').grid(row=1, column=1, sticky=tk.W, pady=(10, 0))
        
        # æ­¥éª¤2: é€‰æ‹©æ•°æ®ç±»å‹
        step2_frame = self.create_step_frame(content_frame, "æ­¥éª¤2: é€‰æ‹©æ•°æ®ç±»å‹", 1)
        
        # æ•°æ®ç±»å‹ç½‘æ ¼
        data_grid_frame = tk.Frame(step2_frame, bg='#ecf0f1')
        data_grid_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=10)
        
        self.type_vars = {}
        row, col = 0, 0
        for i, (data_type, config) in enumerate(self.patterns.items()):
            var = tk.BooleanVar(value=True)
            self.type_vars[data_type] = var
            
            cb = tk.Checkbutton(data_grid_frame, 
                               text=f"  {config['icon']} {config['description']}",
                               variable=var,
                               font=("å¾®è½¯é›…é»‘", 9),
                               bg='#ecf0f1',
                               activebackground='#ecf0f1',
                               selectcolor='#3498db')
            cb.grid(row=row, column=col, sticky=tk.W, padx=(0, 15), pady=2)
            
            col += 1
            if col >= 4:
                col = 0
                row += 1
        
        # é€‰æ‹©æŒ‰é’®
        btn_frame = tk.Frame(step2_frame, bg='#ecf0f1')
        btn_frame.grid(row=1, column=0, columnspan=2, pady=10)
        
        tk.Button(btn_frame, text="âœ… å…¨é€‰", 
                 command=self.select_all_types,
                 bg='#27ae60', fg='white', font=("å¾®è½¯é›…é»‘", 9)).pack(side=tk.LEFT, padx=(0, 10))
        
        tk.Button(btn_frame, text="âŒ å…¨ä¸é€‰", 
                 command=self.deselect_all_types,
                 bg='#e74c3c', fg='white', font=("å¾®è½¯é›…é»‘", 9)).pack(side=tk.LEFT)
        
        # æ­¥éª¤3: è¾“å‡ºè®¾ç½®
        step3_frame = self.create_step_frame(content_frame, "æ­¥éª¤3: è¾“å‡ºè®¾ç½®", 2)
        
        tk.Label(step3_frame, text="è¾“å‡ºç›®å½•:", bg='#ecf0f1', font=("å¾®è½¯é›…é»‘", 9)).grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        
        self.output_var = tk.StringVar(value="output")
        self.output_entry = tk.Entry(step3_frame, textvariable=self.output_var, width=50, font=("å¾®è½¯é›…é»‘", 9))
        self.output_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 10))
        
        tk.Button(step3_frame, text="ğŸ“ æµè§ˆ", 
                 command=self.browse_output,
                 bg='#3498db', fg='white', font=("å¾®è½¯é›…é»‘", 9)).grid(row=0, column=2)
        
        # æ§åˆ¶æŒ‰é’®åŒºåŸŸ
        button_frame = tk.Frame(content_frame, bg='#ecf0f1')
        button_frame.grid(row=3, column=0, columnspan=2, pady=15)
        
        # å¼€å§‹æ‰«ææŒ‰é’®
        self.scan_button = tk.Button(button_frame, 
                                    text="ğŸš€ å¼€å§‹æ‰«æ", 
                                    command=self.start_scan,
                                    bg='#e67e22', fg='white', font=("å¾®è½¯é›…é»‘", 10, "bold"),
                                    width=12, height=1)
        self.scan_button.pack(side=tk.LEFT, padx=(0, 10))
        
        # å¯¼å‡ºç»“æœæŒ‰é’®
        self.export_button = tk.Button(button_frame, 
                                      text="ğŸ’¾ å¯¼å‡ºç»“æœ", 
                                      command=self.export_results,
                                      bg='#9b59b6', fg='white', font=("å¾®è½¯é›…é»‘", 10, "bold"),
                                      width=12, height=1,
                                      state="disabled")  # åˆå§‹ç¦ç”¨
        self.export_button.pack(side=tk.LEFT, padx=(0, 10))
        
        # æ¸…ç©ºæ—¥å¿—æŒ‰é’®
        tk.Button(button_frame, text="ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—", 
                 command=self.clear_log,
                 bg='#95a5a6', fg='white', font=("å¾®è½¯é›…é»‘", 9)).pack(side=tk.LEFT, padx=(0, 10))
        
        # æ‰“å¼€è¾“å‡ºç›®å½•æŒ‰é’®
        tk.Button(button_frame, text="ğŸ“‚ æ‰“å¼€ç›®å½•", 
                 command=self.open_output_dir,
                 bg='#3498db', fg='white', font=("å¾®è½¯é›…é»‘", 9)).pack(side=tk.LEFT)
        
        # è¿›åº¦æ˜¾ç¤ºåŒºåŸŸ
        progress_frame = tk.Frame(content_frame, bg='#ecf0f1')
        progress_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 10))
        
        # è¿›åº¦æ ‡ç­¾
        self.progress_label = tk.Label(progress_frame, 
                                      text="è¿›åº¦: ç­‰å¾…å¼€å§‹", 
                                      bg='#ecf0f1', 
                                      font=("å¾®è½¯é›…é»‘", 9))
        self.progress_label.pack(side=tk.LEFT)
        
        # è¿›åº¦æ¡
        self.progress_bar = ttk.Progressbar(progress_frame, 
                                           mode='determinate',
                                           length=400)
        self.progress_bar.pack(side=tk.RIGHT, fill=tk.X, expand=True, padx=(10, 0))
        
        # æ—¥å¿—åŒºåŸŸ
        log_frame = self.create_step_frame(content_frame, "ğŸ“ æ‰«ææ—¥å¿—", 5)
        log_frame.grid_rowconfigure(0, weight=1)
        content_frame.grid_rowconfigure(5, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, 
                                                 height=15, 
                                                 font=("Consolas", 9),
                                                 bg='#2c3e50',
                                                 fg='#ecf0f1',
                                                 insertbackground='white')
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # çŠ¶æ€æ 
        status_frame = tk.Frame(self.main_container, bg='#34495e', height=25)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        status_frame.pack_propagate(False)
        
        self.status_var = tk.StringVar(value="ğŸŸ¢ å°±ç»ª - æ¬¢è¿ä½¿ç”¨æ•°æ®å®‰å…¨æå–å·¥å…·")
        status_label = tk.Label(status_frame, 
                               textvariable=self.status_var, 
                               bg='#34495e', 
                               fg='#ecf0f1',
                               font=("å¾®è½¯é›…é»‘", 9))
        status_label.pack(side=tk.LEFT, padx=10)
    
    def create_step_frame(self, parent, title, row):
        """åˆ›å»ºæ­¥éª¤æ¡†æ¶"""
        frame = tk.LabelFrame(parent, text=title, bg='#ecf0f1', fg='#2c3e50', 
                             font=("å¾®è½¯é›…é»‘", 10, "bold"), padx=10, pady=10)
        frame.grid(row=row, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        frame.columnconfigure(1, weight=1)
        return frame
    
    def update_progress(self, value, text=""):
        """æ›´æ–°è¿›åº¦æ¡å’Œè¿›åº¦æ ‡ç­¾"""
        self.progress_bar['value'] = value
        if text:
            self.progress_label.config(text=f"è¿›åº¦: {text}")
        self.root.update()
    
    def browse_file(self):
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©è¦æ‰«æçš„æ–‡ä»¶",
            filetypes=[
                ("æ–‡æœ¬æ–‡ä»¶", "*.txt"),
                ("ä»£ç æ–‡ä»¶", "*.js *.css *.html *.xml *.json"),
                ("é…ç½®æ–‡ä»¶", "*.conf *.config *.ini *.yaml *.yml"),
                ("æ‰€æœ‰æ–‡ä»¶", "*.*")
            ]
        )
        if filename:
            self.target_var.set(filename)
            self.status_var.set(f"ğŸ“„ å·²é€‰æ‹©æ–‡ä»¶: {os.path.basename(filename)}")
    
    def browse_directory(self):
        directory = filedialog.askdirectory(title="é€‰æ‹©è¦æ‰«æçš„ç›®å½•")
        if directory:
            self.target_var.set(directory)
            self.status_var.set(f"ğŸ“ å·²é€‰æ‹©ç›®å½•: {os.path.basename(directory)}")
    
    def browse_output(self):
        directory = filedialog.askdirectory(title="é€‰æ‹©è¾“å‡ºç›®å½•")
        if directory:
            self.output_var.set(directory)
    
    def select_all_types(self):
        for var in self.type_vars.values():
            var.set(True)
        self.status_var.set("âœ… å·²å…¨é€‰æ‰€æœ‰æ•°æ®ç±»å‹")
    
    def deselect_all_types(self):
        for var in self.type_vars.values():
            var.set(False)
        self.status_var.set("âŒ å·²å–æ¶ˆæ‰€æœ‰é€‰æ‹©")
    
    def get_selected_types(self):
        return [data_type for data_type, var in self.type_vars.items() if var.get()]
    
    def log(self, message):
        """æ·»åŠ æ—¥å¿—"""
        self.log_text.insert(tk.END, f"{message}\n")
        self.log_text.see(tk.END)
        self.root.update()
    
    def clear_log(self):
        """æ¸…ç©ºæ—¥å¿—"""
        self.log_text.delete(1.0, tk.END)
        self.status_var.set("ğŸ—‘ï¸ æ—¥å¿—å·²æ¸…ç©º")
    
    def start_scan(self):
        """å¼€å§‹æ‰«æ"""
        if self.is_scanning:
            return
        
        target = self.target_var.get().strip()
        if not target:
            messagebox.showerror("é”™è¯¯", "è¯·é€‰æ‹©æ‰«æç›®æ ‡")
            return
        
        if not os.path.exists(target):
            messagebox.showerror("é”™è¯¯", "ç›®æ ‡è·¯å¾„ä¸å­˜åœ¨")
            return
        
        selected_types = self.get_selected_types()
        if not selected_types:
            messagebox.showerror("é”™è¯¯", "è¯·è‡³å°‘é€‰æ‹©ä¸€ç§æ•°æ®ç±»å‹")
            return
        
        output_dir = self.output_var.get().strip()
        if not output_dir:
            output_dir = "output"
        
        # é‡ç½®è¿›åº¦æ¡
        self.progress_bar['value'] = 0
        self.export_button.config(state="disabled")
        
        # åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œæ‰«æ
        self.is_scanning = True
        self.scan_button.config(state="disabled")
        self.status_var.set("ğŸ” æ‰«æè¿›è¡Œä¸­...")
        
        thread = threading.Thread(
            target=self.perform_scan,
            args=(target, selected_types, output_dir)
        )
        thread.daemon = True
        thread.start()
    
    def perform_scan(self, target, selected_types, output_dir):
        """æ‰§è¡Œæ‰«æ"""
        try:
            self.log("=" * 50)
            self.log("ğŸš€ å¼€å§‹æ•°æ®æ‰«æä»»åŠ¡")
            self.log("=" * 50)
            self.log(f"ğŸ“‹ ç›®æ ‡: {target}")
            self.log(f"ğŸ¯ æ•°æ®ç±»å‹: {', '.join([self.patterns[t]['description'] for t in selected_types])}")
            self.log(f"ğŸ’¾ è¾“å‡ºç›®å½•: {output_dir}")
            self.log("")
            
            # åˆ›å»ºè¾“å‡ºç›®å½•
            output_path = Path(output_dir)
            output_path.mkdir(exist_ok=True)
            
            # æ‰§è¡Œæ‰«æ
            if os.path.isfile(target):
                self.update_progress(30, "æ­£åœ¨æ‰«ææ–‡ä»¶...")
                results = self.scan_file(target, selected_types)
                if results:
                    self.scan_results = {target: results}
                    self.update_progress(70, "æ­£åœ¨ä¿å­˜ç»“æœ...")
                    self.save_results(results, output_path, target)
                    self.update_progress(100, "æ‰«æå®Œæˆ!")
                else:
                    self.log("âŒ æœªæ‰¾åˆ°ä»»ä½•åŒ¹é…çš„æ•°æ®")
                    self.update_progress(100, "æ‰«æå®Œæˆ")
            else:
                self.update_progress(10, "æ­£åœ¨æ‰«æç›®å½•...")
                all_results = self.scan_directory(target, selected_types, output_path)
                if all_results:
                    self.scan_results = all_results
                    self.update_progress(80, "æ­£åœ¨åˆå¹¶ç»“æœ...")
                    self.save_batch_results(all_results, output_path)
                    self.update_progress(100, "æ‰«æå®Œæˆ!")
                else:
                    self.log("âŒ æœªåœ¨ä»»ä½•æ–‡ä»¶ä¸­æ‰¾åˆ°åŒ¹é…çš„æ•°æ®")
                    self.update_progress(100, "æ‰«æå®Œæˆ")
            
            self.log("")
            self.log("âœ… æ‰«æä»»åŠ¡å®Œæˆ!")
            
        except Exception as e:
            self.log(f"ğŸ’¥ æ‰«æå‡ºé”™: {str(e)}")
            self.update_progress(100, "æ‰«æå‡ºé”™")
        finally:
            self.is_scanning = False
            self.root.after(0, self.scan_complete)
    
    def scan_complete(self):
        """æ‰«æå®Œæˆåçš„æ¸…ç†å·¥ä½œ"""
        self.scan_button.config(state="normal")
        self.status_var.set("ğŸŸ¢ æ‰«æå®Œæˆ")
        # å¦‚æœæœ‰æ‰«æç»“æœï¼Œå¯ç”¨å¯¼å‡ºæŒ‰é’®
        if self.scan_results:
            self.export_button.config(state="normal")
    
    def scan_file(self, file_path, selected_types):
        """æ‰«æå•ä¸ªæ–‡ä»¶"""
        self.log(f"ğŸ“„ å¤„ç†æ–‡ä»¶: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            results = {}
            for data_type in selected_types:
                config = self.patterns[data_type]
                matches = re.findall(config['pattern'], content)
                
                if matches:
                    unique_matches = []
                    for match in matches:
                        if match not in unique_matches:
                            unique_matches.append(match)
                    
                    results[data_type] = unique_matches
                    self.log(f"  âœ… {config['icon']} {config['description']}: {len(unique_matches)} æ¡")
            
            return results if results else None
            
        except Exception as e:
            self.log(f"  âŒ è¯»å–æ–‡ä»¶å¤±è´¥: {str(e)}")
            return None
    
    def scan_directory(self, directory, selected_types, output_path):
        """æ‰«æç›®å½•"""
        extensions = ['.txt', '.log', '.conf', '.js', '.css', '.html', '.xml', 
                     '.json', '.yaml', '.yml', '.csv', '.md', '.rst', '.ini', '.config']
        
        all_results = {}
        total_files = 0
        found_files = 0
        
        path = Path(directory)
        file_iterator = path.rglob('*') if self.recursive_var.get() else path.glob('*')
        files = [f for f in file_iterator if f.is_file() and f.suffix.lower() in extensions]
        total_files = len(files)
        
        for i, file_path in enumerate(files):
            progress = 10 + (i / total_files) * 60  # 10%åˆ°70%
            self.update_progress(progress, f"æ‰«ææ–‡ä»¶ä¸­ ({i+1}/{total_files})")
            
            results = self.scan_file(str(file_path), selected_types)
            if results:
                found_files += 1
                all_results[str(file_path)] = results
        
        return all_results
    
    def save_results(self, results, output_path, source):
        """ä¿å­˜å•ä¸ªæ–‡ä»¶çš„ç»“æœ"""
        total_count = 0
        
        for data_type, matches in results.items():
            config = self.patterns[data_type]
            filename = f"{data_type}.txt"
            filepath = output_path / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write('[')
                f.write(','.join([f'"{match}"' for match in matches]))
                f.write(']')
            
            total_count += len(matches)
            self.log(f"ğŸ’¾ ä¿å­˜ {config['description']} åˆ°: {filename} ({len(matches)} æ¡)")
        
        self.log(f"ğŸ“Š æ€»è®¡ä¿å­˜: {total_count} æ¡æ•°æ®")
    
    def save_batch_results(self, all_results, output_path):
        """ä¿å­˜æ‰¹é‡æ‰«æç»“æœ"""
        merged_results = {}
        
        # åˆå¹¶æ‰€æœ‰æ–‡ä»¶çš„ç»“æœ
        for file_results in all_results.values():
            for data_type, matches in file_results.items():
                if data_type not in merged_results:
                    merged_results[data_type] = []
                merged_results[data_type].extend(matches)
        
        # å»é‡å¹¶ä¿æŒé¡ºåº
        for data_type in merged_results:
            unique_matches = []
            for match in merged_results[data_type]:
                if match not in unique_matches:
                    unique_matches.append(match)
            merged_results[data_type] = unique_matches
        
        # ä¿å­˜åˆå¹¶ç»“æœ
        total_count = 0
        
        for data_type, matches in merged_results.items():
            config = self.patterns[data_type]
            filename = f"{data_type}.txt"
            filepath = output_path / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write('[')
                f.write(','.join([f'"{match}"' for match in matches]))
                f.write(']')
            
            total_count += len(matches)
            self.log(f"ğŸ’¾ ä¿å­˜ {config['description']} åˆ°: {filename} ({len(matches)} æ¡)")
        
        # ç»Ÿè®¡ä¿¡æ¯
        total_files = len(all_results)
        self.log(f"ğŸ“ˆ æ‰«æç»Ÿè®¡:")
        self.log(f"  ğŸ“ æ€»æ–‡ä»¶æ•°: {total_files}")
        self.log(f"  ğŸ“Š æ€»æ•°æ®æ¡æ•°: {total_count}")
    
    def export_results(self):
        """å¯¼å‡ºç»“æœåˆ°æŒ‡å®šæ–‡ä»¶"""
        if not self.scan_results:
            messagebox.showwarning("è­¦å‘Š", "æ²¡æœ‰å¯å¯¼å‡ºçš„æ‰«æç»“æœ")
            return
        
        # é€‰æ‹©å¯¼å‡ºæ–‡ä»¶ä½ç½®
        filename = filedialog.asksaveasfilename(
            title="å¯¼å‡ºæ‰«æç»“æœ",
            defaultextension=".json",
            filetypes=[("JSONæ–‡ä»¶", "*.json"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        
        if not filename:
            return
        
        try:
            # å‡†å¤‡å¯¼å‡ºæ•°æ®
            export_data = {
                "export_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "scan_results": self.scan_results,
                "patterns_used": {k: self.patterns[k]['description'] for k in self.get_selected_types()}
            }
            
            # ä¿å­˜ä¸ºJSON
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, ensure_ascii=False, indent=2)
            
            self.log(f"ğŸ’¾ ç»“æœå·²å¯¼å‡ºåˆ°: {filename}")
            self.status_var.set(f"âœ… ç»“æœå·²å¯¼å‡º: {os.path.basename(filename)}")
            
        except Exception as e:
            messagebox.showerror("å¯¼å‡ºé”™è¯¯", f"å¯¼å‡ºå¤±è´¥: {str(e)}")
    
    def open_output_dir(self):
        """æ‰“å¼€è¾“å‡ºç›®å½•"""
        output_dir = self.output_var.get().strip()
        if not output_dir:
            output_dir = "output"
        
        if os.path.exists(output_dir):
            os.startfile(output_dir)
        else:
            messagebox.showwarning("è­¦å‘Š", "è¾“å‡ºç›®å½•ä¸å­˜åœ¨")

def main():
    root = tk.Tk()
    app = DataExtractorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()